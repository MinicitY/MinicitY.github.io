---
layout: post
title:  "算导注解Chapter[6]"
date:   2018-06-29
author: MinicitY
categories: Algorithm
tags: 堆排序
---

* content
{:toc}

## **Preview**
接下来的几章我们会把所有的排序都讲完，包括这本书完全没提到过的希尔排序（所以也就只简要讲讲定义_(:3 」∠ )_ ）

先修知识：
排序有很多应用。比如银行对数据库中的编号进行排序，专业软件内的图层按次序来排序。

如果输入的数组仅有常数个元素需要在排序过程中储存在原数组之外，那么相关的排序算法就被称为是**原址的**。堆排、快排都是原址排序算法。决策树模型可以用来研究基于比较的排序算法的性能局限。

![](https://github.com/MinicitY/MyImg/blob/master/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%97%B6%E9%97%B4%E6%AF%94%E8%BE%83.png?raw=true)




_书上的排序运行时间比较图_

一个二叉树，在最后一层的所有结点都集中在最左边，而在其他所有层的结点数都达到应有的理论上限，这样的二叉树是完全二叉树。堆是数组，但可以被看成是一个近似的完全二叉树。

一个堆的下标i应该按照每层向右、逐层往下、下层必定大于上层的顺序标注。以下代码可以计算一个结点的父结点和子结点：

```
PARENT (i)
return⌊i/2⌋

LEFT(i)
return 2i

RIGHT(i)
return 2i+1
```

## **维护堆的性质**

**最大堆**的性质是指除了根以外的所有结点i都要满足：
` A[PARENT(i)] >= A[i] `

**最小堆**的性质是指除了根以外的所有结点i都要满足：
` A[PARENT(i)] <= A[i] `

## **建堆**

## **堆排序**

#### 算法

#### 实现优先队列

## **题目答案**
