---
layout: post
title:  "算导注解Chapter[1&2&3]"
date:   2018-06-23
author: MinicitY
categories: Algorithm
tags: 分治法 
---
* content
{:toc}

## **Preview**
写在前面：想了很久决定还是简要讲下这三章。毕竟算法分析和渐进求解也算是我的弱项：P

关键字： `数学归纳法` `分治` `渐进记号` 

先修知识：
``` 
> 为什么二分查找的O(n)=logn？
> 对于一个2^n个元素的查找串，二分查找的折叠过程每次将查找串折半。
  假设目标元素在查找串的最边缘位置，那么这个过程「n/2/2/2...=1」执行的次数自然是logn
```




## 算法基础
#### 插入排序算法证明

插入排序，冒泡排序和选择排序。这三种排序实在过于简单，简单到除了应试题以外在实际应用中几乎见不到。虽然在数据量较小的时候其实它们是要比归并更快的（毕竟实际的用时不仅仅只考虑Comparison times），但你可能更倾向于用sort方法搞定一切——除非数据量足够小而你仍然要进行优化，那么这个时候请按这些排序的命名自己边猜边写吧。

``` java
1 for index = 2 to array.length {
2  key = array[index]
3  index2 = index – 1
4  while index2 > 0 && array[index2]> key {
5   array[index2 + 1] = array[index2]
6   index2 = index2 - 1}
7  array[index2 + 1] = key}
```

显而易见地，对于一个近似有序的数据，插入排序的时间复杂度是n，而同为原址排序的快速排序则可能是n^2。这是除了小数据量以外唯一我能想到的插排比快排稳定的时候了。

我们可以简要地证明这个插入排序算法的正确性。

1. _初始化_：将已经参与排序的数字视为一个额外的数组。把这个额外数组保持有序的性质叫做循环不变式。

2. _保持_：每次循环时都会进行相应操作，并且带来一个新的元素。对于第一次操作，只有两个数参与，很明显结果会是一个有序的数组，即循环不变式成立。每次加入的新元素都会被插入到一个合适的位置以保证有序，也就是说每一次循环操作后循环不变式都成立。

3. _终止_：最终结果必然满足循环不变式，即有序。


这个过程本身就是**数学归纳法**。实际上很多的算法证明都依赖于数学归纳法，比如旅行商问题的分支界限法，以及求解最长公共子序列就需要每次循环之后验证目前的路线是否是局部最优解。往后的算法证明中若有简单的数学归纳法将不再赘述。

***

#### 分析插入排序算法

一条指令所消耗的时间不一定是常量时间。比如，a^n需要执行乘法n次，而乘法又需要n次加法。值得一提的是，计算2^k对于二进制计算机而言只需要将整数左移就可以在常量时间内得到答案，但在计算前进行if判断显然又会拖累其他可能的计算。

以插入排序为例子来探究算法的分析或许更有意义。上述七行插入排序的算法，每一行可以认为执行一次需要一定的代价(cost)，比如赋值，迭代，比较等等。在while区块之前和之后的语句，每一行执行n级别的次数。在while区块内部的语句，可以认为是循环嵌套，即变相求和，**求每一次进入while所执行该行的次数的和。**

`T(n) = c1n + c2(n-1) + c3(n-1) + c4(求和) + c5(求和) + c6(求和) + c7(n-1)`

//cx=第x行的cost，懒得写求和公式了

显然地，当目标无限近似有序时，求和部分变成 n-1， 那么该算法所消耗的时间只取决于 n 的大小和每行的「cost」。当目标无限近似反向有序时，求和部分变成n(n+1)/2-1 以及 n(n-1)/2，那么最坏情况下T(n)将变成n的二次函数，取决于n^2的大小和每行的「cost」。

***

#### 归并排序的分析

归并排序的伪代码和过程不再赘述。值得一提的是，归并排序是先分后治，分的时候基于递归，而合并的时候基于迭代。迭代的过程又是一种**数学归纳法**，因此归并排序算法的正确性是可以容易地证明的。分治策略的通用递归式和上下界处理将在第四章和第八章进一步讨论。

![](https://github.com/MinicitY/MyImg/blob/master/mergeSort.png?raw=true)

_总 cost = cnlogn+cn的由来，另一个cn比较次数将在之后讨论_
## **时间复杂度**

>Θ(g(n)) = {f(n): 存在正常量c1, c2和n0，使得对所有n>=n0， 有0 <= c1g(n) <= f(n) <= c2g(n)}
>O(g(n)) = {f(n): 存在正常量c和n0，使得对所有n>=n0，有0 <= f(n) <= cg(n)}
>Ω(g(n)) = {f(n): 存在正常量c和n0，使得对所有n>=n0，有0 <= cg(n) <= f(n)}
 


## **思考题选讲**
