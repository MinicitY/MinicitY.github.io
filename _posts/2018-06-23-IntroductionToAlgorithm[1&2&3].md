---
layout: post
title:  "《算法导论》注解Chapter[1&2&3]"
date:   2018-06-23
author: MinicitY
categories: Algorithm
tags: 分治法 
---
* content
{:toc}

## **Preview**
写在前面：想了很久决定还是详细点讲这三章。毕竟算法分析和渐进求解也算是我的弱项：P

关键字： `数学归纳法` `分治` `渐进记号` 

先修知识：
``` 

> 为什么二分查找的O(n)=logn？
- 对于一个2^n个元素的查找串，二分查找的折叠过程每次将查找串折半。
  假设目标元素在查找串的最边缘位置，那么这个过程「n/2/2/2...=1」
  执行的次数自然是logn

```

#### **插入排序算法证明**

插入排序，冒泡排序和选择排序。这三种排序实在过于简单，简单到除了应试题以外在实际应用几乎见不到。虽然在数据量较小的时候其实它们比归并是要更快的（毕竟实际的用时不仅仅只考虑Comparison times），但你可能更倾向于用sort方法搞定一切——除非数据量足够小而你仍然要进行优化，那么这个时候请按这些排序的命名自己边猜边写吧。

```
for index = 2 to array.length {
 key = A[index]
 index2 = index – 1
  while index2 > 0 && array[index2]> key {
   array[index2 + 1] = array[index2]
   index2 = index2 - 1
}
  Array[index2+1] = key
}
```

>显而易见地，对于一个近似有序的数据，插入排序的时间复杂度是n，而同为原址排序的快速排序是可能是n^2。这是除了小数据量以外唯一我能想到的插排比快排稳定的时候了。
>
>我们可以简要地证明这个插入排序算法的正确性。
>
>*初始化*：将已经参与排序的数字视为一个额外的数组。把这个额外数组保持有序的性质叫做循环不变式。
>
>*保持*：每次循环时都会进行相应操作，并且带来一个新的元素。对于第一次操作，只有两个数参与，很明显结果会是一个有序的数组，即循环不变式成立。每次加入的新元素都会被插入到一个合适的位置以保证有序，也就是说每一次循环操作后循环不变式都成立。
>
>*终止*：最终结果必然满足循环不变式，即有序。


这个过程本身就是**数学归纳法**。实际上很多的算法证明都依赖于数学归纳法，比如旅行商问题的分支界限法，以及求解最长公共子序列就需要每次循环之后验证目前的路线是否是局部最优解。往后的算法证明中若有简单的数学归纳法将不再赘述。

***

#### 分析算法
以插入排序为例子来探究算法的分析或许更有意义。


***
#### 归并排序的分析


## **时间复杂度**


## **思考题选讲**
