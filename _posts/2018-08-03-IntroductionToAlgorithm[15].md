---
layout: post
title:  "算导注解Chapter[15]"
date:   2018-08-03
author: MinicitY
categories: Algorithm
tags: 动态规划
---

* content
{:toc}

## **Preview**

**动态规划**方法是一种对具有交叠子问题的问题进行求解的技术。如果不同的子问题拥有公共的子子问题，那么分治算法的递归里有可能会反复地求解一个公共的子子问题。不得不承认，DP(dynamic program)大概是本书唯一能够抗衡分治法的存在了。尽管这本书没有提到Warshall和Ford，没有背包问题也没有小机器人，剩下的文字依然皓如繁星。愿天堂没有DP。

先修知识：

**钢条切割问题**指的是，将一条长钢条切割成几条短钢条出售，求解售价最大化问题。其中不同长度的钢条的价格不同，甚至也会出现根本不切割而利益最大的情形。也可以概括为，利用手上限额的资源，合理分配以达到利益最大化的问题。

**最长公共子序列问题**指的是，求解两个序列的最长的相同子序列。子序列所含元素在序列中的位置下标应该是严格递增的。例如，Z={B,C,D,B}是X={A,B,C,B,D,A,B}的子序列，此时位置下标为{1,2,4,6}。



## **钢条切割**

我们来研究一下钢条切割问题。

| 长度i | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 |
| 价格p | 1 | 5 | 8 | 9 | 10 | 17 | 17 | 20 | 24 | 30 |

如果要考虑总价最高的算法，直接求单位价格是不合理的。我们先利用穷举的方法考虑总长n=4英寸时的情况：

`4`  `1 3`  `2 2`  `3 1`
`1 1 2`  `1 2 1`  `2 1 1`  `1 1 1 1`

_4英寸钢条的8种切割方案_

当长度为4英寸的钢条被切割成两条2英寸的钢条时，总价格最高为10，为最优解。同时我们也发现，单位价格最高的长度3（8/3=2.67）并没有被选择，许多重复的情况也被考虑。我们对总长度在1~10之间的钢条全部切割一遍，并观测它们的最优切割方案：

| 总长度 | 是否产生切割 | 切割方案 |
| :------| :------: | :------: |
| 1 | no | 1 |
| 2 | no | 2 |
| 3 | no | 3 |
| 4 | yes | 2+2 |
| 5 | yes | 2+3 |
| 6 | no | 6 |
| 7 | yes | 1+6 or 2+2+3 |
| 8 | yes | 2+6 |
| 9 | yes | 3+6 |
| 10 | no | 10 |

我们可以发现这么几点规律（至少对于1~10的长度而言）：

- 如果单价高于所有小于自己长度的单价，则不切割，并作为一个**最优子结构**

- 如果单价低于任意一个小于自己长度的单价，则切割为数个**最优子结构**

- 由于「总长度为1」本身一定是**最优子结构**，因此任何一种长度都**可以**分割成最优子结构。

显然地，钢条的切割只能是最优解。它要么自成一派，成为一个最优子结构，要么一定是几个最优子结构的和——除非它无法被分解为几个最优子结构，然而这对于钢条切割来说是不可能的，「总长度为1」本身一定是最优子结构。因此，我们把这个规律推广开来，成为钢条切割问题的递归通解。

可以实现这个递归通解：

```java
CUT(p,n)//p is an array of price
 if n == 0//finish cut
  return 0
 q = 0
 for i =1 to n
  q = max(q, p[i] + CUT(p, n-i))
 return q
```

如果画出这个算法的递归树，会发现这个算法难以处理大规模的数据—— **每次调用cut(p, n-i)都会把已经计算过的情形再次调用一遍。** 实际上这个算法的时间复杂度为2^n级别。这是递归方法的一个巨大缺陷，直接从顶向下的递归实现需要一个数据记录。

为了改进这个算法，我们有两种方式——其一是对从顶向下的实现加上一个数据记录，其二是干脆用自底向上来实现。前者虽然时间复杂度差不多但分析比较麻烦，我们用自底向上会方便不少。

```java
BOTTOM-UP-CUT(p, n)
 r[0...n] be a new array
 r[0] = 0
 for j = 1 to n
  q = 0//用q来储存最优子结构
  for i = 1 to j
   q = max(q, p[i] + r[j-i])
  r[j] = q
 return r[n]
```

在这个过程中，我们引入了动态规划的思想，也就是仔细安排求解的顺序，以达到每个子问题只求解一次的极高效率，同时将结果保存下来。因此用时Θ(n^2)。

值得注意的是，如果我们要给出真正的答案，还需要重构解，让每个最优子结构储存相应的切割方案，最后让算法返回切割方案才能解决实际问题。

![](https://raw.githubusercontent.com/MinicitY/MyImg/master/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E2%80%94%E2%80%94%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91.png)

_不要忘记动态规划也常常用来求解斐波那契数_

## **动态规划原理**



## **最长公共子序列**

## **最优二叉搜索树**

## **题目答案**