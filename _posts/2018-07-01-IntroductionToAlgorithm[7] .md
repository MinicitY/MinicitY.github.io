---
layout: post
title:  "算导注解Chapter[7]"
date:   2018-07-01
author: MinicitY
categories: Algorithm
tags: 快速排序
---

* content
{:toc}

## **Preview**
这里主要讲快速排序的代码，证明，不同版本以及分析。最后会写一点关于归并排序、堆排序和快速排序的一点感想。这一章相对来说比较简单，知识点的把握没有什么难度。

Keywords: `分治法` `期望运行时间`




## **算法介绍**

快速排序的思路与归并排序非常接近。归并排序讲究先分再治，而快速排序将目标数组先 _分解_ 为两个子数组，并保证一个子数组中的所有的值都小于等于另一个子数组中的任何一个值。注意，将原数组划分为两个子数组不需要规定子数组的大小，但要计算用来分割的下标。接着快排**递归调用**来 _解决_ 剩下的排序。由于快排是原址排序，所以 _合并_ 部分不需要像归并排序那样复杂。

只有遵循上述的  _分解_、_解决_、_合并_ 操作的排序才是快速排序。我们可以敏锐地发现，不同于能够在线性时间内构造有顺序的（尽管不是严格顺序的）堆排序，快速排序和归并排序的构造顺序依赖于**分治法**，而每分解一步就治理一步的特点又把快排和归并区别开来。

#### 代码与证明

我们以从小到大排序为例：

```java
QUICKSORT(A,p,r)//p,r的初始值是1和A.length
 if p<r
  q = PARTITION(A,p,r)//将数组分割，让元素们站好队，并返回pivot
  QUICKSORT(A,p,q - 1)
  QUICKSORT(A,q +1, r)
```
计算PARTITION：

```java
PARTITION(A,p,r)
x = A[r]//将A[r]作为一个pivot
i = p - 1
for j = p to r - 1
  if A[j] <= x
   i = i + 1
   exchange A[i] with A[j]//比pivot小的元素放到左边
 exchange A[i + 1] with A[r]//pivot放到比自己小的那一堆的元素们的刚好右边
 return i +1
```
有意思的是，指针 j 将遍历录入数组从左到右的下标（除了被选为pivot的A[r]），而指针 i 所指向的下标负责接收储存下一个被判定为「比pivot还小」的值。显然地，在 j 遍历的过程中，我们对 j 右边的数字们是不感兴趣的，而 i 左边的数字们是必须有「比pivot还小」的义务。因此，我们把以下性质当作**循环不变量**：

每一次循环开始时，对于任意一个值「k」，有：
1. 若 p <= k <= i ，则A[k] <= x
2. 若 i+1 <= k <= j - 1 ，则A[k] > x
3. 若 k = r ，则A[k] = x

对于这三点，我们仍然可以利用**数学归纳法**来证明它们的正确性。证明过程依然分为 _初始化_ 、 _保持_ 、 _终止_ 三个部分。具体过程比较简单就略过了。以上我们就证明了快速排序的正确性。

#### 随机化版本

用非固定的下标来控制的快速排序在稳定性方面总是让我们联想到插入排序。插入排序典型的矛盾在于，对于一个逆有序数组，插入排序所消耗的时间必然是Θ(n^2)。快速排序也存在类似的矛盾，有序数组的劣质pivot会导致每次遍历一遍都找不出比pivot还小的元素，并且让这时候的快排看起来像插入排序的一种特殊情况，耗时还是Θ(n^2)——尤其是当实际情况很有可能出现有序数组，比如对一个储存最小堆的数组使用从小到大的快速排序的时候。现在我们可以考虑利用**随机抽样**来降低实际情况中出现有序排列的可能性。

```java
RANDOMIZED-QUICKSORT(A,p,r)
 i = RANDOM(p,r)
 exchange A[r] with A[i]
 return PARTITION(A,p,r)
```

另外的两个算法只需要做微小的改动，在此不表。其他具体的分析我们将稍后讲解。

## **性能分析**

## **Ω/Θ(nlogn)的思考**

## **题目答案**
