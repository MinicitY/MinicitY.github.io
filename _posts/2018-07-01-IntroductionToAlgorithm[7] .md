---
layout: post
title:  "算导注解Chapter[7]"
date:   2018-07-01
author: MinicitY
categories: Algorithm
tags: 快速排序
---

* content
{:toc}

## **Preview**
这里主要讲快速排序的代码，证明，不同版本以及分析。最后会写一点关于归并排序、堆排序和快速排序的一点感想。这一章相对来说比较简单，知识点的把握没有什么难度。

Keywords: `分治法` `期望运行时间`




## **算法介绍**

快速排序的思路与归并排序非常接近。归并排序讲究先分再治，而快速排序将目标数组先 _分解_ 为两个子数组，并保证一个子数组中的所有的值都小于等于另一个子数组中的任何一个值。注意，将原数组划分为两个子数组不需要规定子数组的大小，但要计算用来分割的下标。接着快排**递归调用**来 _解决_ 剩下的排序。由于快排是原址排序，所以 _合并_ 部分不需要像归并排序那样复杂。

只有遵循上述的  _分解_、_解决_、 _合并_ 操作的排序才是快速排序。我们可以敏锐地发现，不同于能够在线性时间内构造有顺序的（尽管不是严格顺序的）堆排序，快速排序和归并排序的构造顺序依赖于**分治法**，而每分解一步就治理一步的特点又把快排和归并区别开来。

#### 代码与证明

```java
QUICKSORT(A,p,r)//p,r的初始值是1和A.length
 if p<r
  q = PARTITION(A,p,r)//将数组分割，让元素们站好队，并返回pivot
  QUICKSORT(A,p,q - 1)
  QUICKSORT(A,q +1, r)
```
计算PARTITION

```java
PARTITION(A,p,r)
x = A[r]//将A[r]作为一个pivot
i = p - 1
for j = p to r - 1
  if A[j] <= x
   i = i + 1
   exchange A[i] with A[j]//比pivot小的元素放到左边
 exchange A[i + 1] with A[r]//pivot放到比自己小的那一堆的元素们的刚好右边
 return i +1
```
有意思的是，指针 j 将遍历录入数组从左到右的下标（除了被选为pivot的A[r]），而指针 i 所指向的下标负责接收储存下一个被判定为「比pivot还小」的值。显然地，在 j 遍历的过程中，我们对 j 右边的数字们是不感兴趣的，而 i 左边的数字们是必须有「比pivot还小」的义务。因此，我们把以下性质当作**循环不变量**：

每一次循环开始时，对于任意一个值「k」，有：
1. 若 p <= k <= i ，则A[k] <= x
2. 若 i+1 <= k <= j - 1 ，则A[k] > x
3. 若 k = r ，则A[k] = x

对于这三点，我们仍然可以利用**数学归纳法**来证明它们的正确性。证明过程依然分为 _初始化_ 、 _保持_ 、 _终止_ 三个部分。具体过程比较简单就略过了。

#### 随机化版本

## **性能分析**

## **Ω/Θ(nlogn)的思考**

## **题目答案**
